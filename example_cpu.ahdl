use std::{full_adder -> adder}
use std::another_adder

namespace stuff {
    namespace inner {
        enum ops { add, sub, shiftl, shiftr, mult }
    }
}

namespace stuff2::inner {
    enum ops[id] { add[0], sub[1], shiftl[2], shiftr[3], mult[6] }
}

namespace cpu {

use stuff::*

union instruction<32>[id<16>]
{
    `when`(id, '?),
    add(id, reg_left: ctrl<4>, reg_right: ctrl<4>, reg_out: ctrl<4>, '?<16>),
    sub(id, reg_left: ctrl<4>, reg_right: ctrl<4>, reg_out: ctrl<4>, '?<16>),
    shiftl(id, reg_left: ctrl<4>, reg_right: ctrl<4>, reg_out: ctrl<4>, '?<16>),
    shiftr(id, reg_left: ctrl<4>, reg_right: ctrl<4>, reg_out: ctrl<4>, '?<16>),
    mult(id, reg_left: ctrl<4>, reg_right: ctrl<4>, reg_out: ctrl<4>, '?),
    bre(id,reg_left: ctrl<4>, '?),
    jmp(id,literal_addr: ctrl<28>),
    load(id, reg_addr: ctrl<4>, '?<4>, reg_out: ctrl<4>, '?<16>),
    store(id, reg_addr: ctrl<4>, reg_: ctrl<4>, '?<20>),
    set(id, reg: ctrl<4>, literal: data<u24>),
    noop(id, '?)
}

module memory<D>[addr<256>]@{clk} (mem_in[addr]: D; wr_en: ctrl) => (mem_out[addr]: D)
{
    bind * <= if wr_en {
        mem_in[addr]@{clk} -> mem_out[addr]@{clk+1};
    } else {
        mem_out[addr]@{clk} -> mem_out[addr]@{clk+1};
    }
}

module mux[element<16>] (target@[element]: data<16>) => (output[element]: data<16>)
{
    bind output[element] <= target@[element]
}

module arith_logic_unit_expr (a: data<s32>; b: data<s32>; op: ops) => (y: data<s33>)
{
    bind y <= match op {
        ops::add => a + b
        ops::sub => a + -b
        ops::shiftl => a << b
        ops::shiftr => a >> b
        ops::mult => a<16:0> * b<16:0>
    }
}

module arith_logic_unit_bind (a: data<s32>; b: data<s32>; op: ops) => (y: data<s33>)
{
    bind * <= match op {
        ops::add => a + b -> y;
        ops::sub => a - b -> y;
        ops::shiftl => a << b -> y;
        ops::shiftr => a >> b -> y;
        ops::mult => a<16:0> * b<16:0> -> y;
    }
}

module regfile[left<16>, right<16>, center<16>, in<16>]@{clk}
(regin[in]: data<u32>; wr_en: ctrl)
=> (regleft[left]: data<u32>; regright[right]: data<u32>; regcenter[center]: data<u32>)
{
    bind regs <= reg[addr<16>]@{clk}: data<u32>
    bind regleft <= regs[left]
    bind regright <= regs[right]
    bind regs[in]@{clk+1} <= regin
}

enum states
{
    fetch, store, exec, wait
}

module program_counter@{clk}(target: data<u32>; set: ctrl; incr: ctrl) => (addr: data<u32>)
{
    bind * <= if set {
        target@{clk} -> addr@{clk+1}
    } else if incr {
        addr@{clk} + 1'b -> addr@{clk+1}
    } else {
        addr@{clk} -> addr@{clk+1}
    }
}

module cpu@{clk} () => ()
{
    use instruction::*

    bind alu <= arith_logic_unit@{clk} (alu_op_a -> a; alu_op_b -> b; alu_op -> op)
    bind (reg_left <- reg_left; reg_right <- reg_right) <= regfile@{clk} (reg_in -> reg_in; reg_wr -> reg_in)
    bind mem_out <= memory<data<u32>>@{clk}(mem_in -> mem_in)
    bind overflow <= reg@{clk}: ctrl<1>
    bind pc <= reg@{clk}: data<u32>

    bind * <= match state@{clk} {
        states::fetch => {
            pc@{clk} + 1'b -> pc@{clk+1};
        }
        states::exec => {
            match mem_out[pc]@{clk} {
                add(_, left, right, out, _) => {
                    ops::add -> alu_op;
                    regleft[left]@{clk} -> alu_op_a;
                    regright[right]@{clk} -> alu_op_b;
                    alu_result<0:32> -> regin[out]@{clk+1};
                    alu_result<32> as ctrl -> overflow@{clk+1};
                    pc@{clk} + 1'b -> pc@{clk+1};
                    states::exec -> state@{clk+1};
                }
                mult(_, left, right, out, _) => {
                    ops::mult -> alu_op;
                    regleft[left]@{clk} -> alu_op_a;
                    regright[right]@{clk} -> alu_op_b;
                    alu_result@{clk+3}<31:0> -> regin[out]@{clk+4};
                    pc@{clk} + 1'b -> pc@{clk+1};
                    states::wait -> state@{clk+1};
                    states::wait -> state@{clk+2};
                    states::wait -> state@{clk+3};
                    states::exec -> state@{clk+4};
                    '0 -> overflow@{clk+1};
                }
                bre(_, target, _) => {
                    if regleft[left]@{clk} == regright[right]@{clk} {
                        reg[target]@{clk} -> pc@{clk+1};
                    } else {
                        pc@{clk} + 1'b -> pc@{clk+1};
                    };
                    states::exec -> state@{clk+1};
                    '0 -> overflow@{clk+1};
                }
                load(_, addr, reg, _) => {
                    mem_out[reg_left[addr]@{clk}]@{clk+1} -> reg_in[reg]@{clk+2};
                    states::wait -> state@{clk+1};
                    states::exec -> state@{clk+2};
                    pc@{clk} + 1'b -> pc@{clk+1};
                    '0 -> overflow@{clk+1};
                }
                store(_, addr, reg, _) => {
                    reg_in[reg]@{clk} -> mem_in[reg_left[reg]@{clk}]@{clk+1};
                    '1 -> mem_wr;
                    states::wait -> state@{clk+1};
                    states::exec -> state@{clk+2};
                }
                nop(_)  => {
                    pc@{clk} + 1'b -> pc@{clk+1};
                }
            }
        }
        states::wait => {
            * -> *;
        }
    }
}

// Weird syntax
/*
encoding bcd;

module bcd<L, T=L+(L-4)/3>: decode<data<bcd<L>>, data<signed<T>>> (input: data<bcd<L>>) => (output: data<signed<T>>)
{
        ....
}

operator *: adder<A, B, Y>(left: data<A>, right: data<B>) => (output: data<Y>);

module carry_lookahead<T>: adder<data<T>, data<T>, data<T>>(left: data<s16>, right: data<s16>) => (output: data<s17>)
{

}
*/
}
