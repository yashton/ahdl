enum ops { add, sub, shiftl, shiftr, mult };

module memory[addr<256>]<D>@{clk} (mem_in[addr]::D, wr_en:: ctrl) => (mem_out[addr]::D)
{

}

module mux[element<16>] (target[element]::data<16>) => (output[element]::data<16>)
{
    let output[element] <= target[element];
}

module arith_logic_unit@{clk} (a::data<32>, b::data<32>, op::ops) => (y::data<33>)
{
    match op:
        op::add: a + b -> y@{clk+1};
	op::sub: a + (-b) -> y@{clk+1};
	op::shiftl: a << b -> y@{clk+1};
	op::shiftr: a >> b -> y@{clk+1};
	op::mult: a<0:16> * b<0:16> -> y@{clk+4};
}

union instruction[id<16>]<u32>
{
    add(id, reg_left::ctrl<4>, reg_right::ctrl<4>, reg_out::ctrl<4>, 'x<16>),
    sub(id, reg_left::ctrl<4>, reg_right::ctrl<4>, reg_out::ctrl<4>, 'x<16>),
    shiftl(id, reg_left::ctrl<4>, reg_right::ctrl<4>, reg_out::ctrl<4>, 'x<16>),
    shiftr(id, reg_left::ctrl<4>, reg_right::ctrl<4>, reg_out::ctrl<4>, 'x<16>),
    mult(id, reg_left::ctrl<4>, reg_right::ctrl<4>, reg_out::ctrl<4>, 'x<16>),
    bre(id,reg_left::ctrl<4>, reg_right::ctrl<4>, reg_out::ctrl<4>, 'x<16>),
    jmp(id,literal_addr::ctrl<28>),
    load(id, reg_addr::ctrl<4>, 'x<4>, reg_out::ctrl<4>, 'x<16>),
    store(id, reg_addr::ctrl<4>, reg_::ctrl<4>, 'x<24>),
    set(id, reg::ctrl<4>, literal::data<u24>)
    nop(id, 'x)
};

module regfile[left<16>, right<16>, center<16>, in<16>]@{clk}
(regin[in]::data<u32>, wr_en::ctrl)
=> (regleft[left]::data<u32>, regright[right]::data<u32>, regcenter[center]::data<u32>)
{
    let regs <= reg[addr<16>]@{clk}::data<u32>;
    regs[left] -> regleft;
    regs[right] -> regright;
    regin -> regs[in]@{clk+1}
}

enum states { fetch, store, exec, wait }

module program_counter@{clk}(target::data<u32>, set::ctrl, incr::ctrl) => (address::data<u32>)
{
    if set:
	target@{clk} -> address@{clk+1}
    else if incr:
	address@{clk} + 1 -> address@{clk+1}
    else:
	address@{clk} -> address@{clk+1}
}

module cpu@{clk}
{
let alu (alu_result) <= arith_logic_unit@{clk} (alu_op_a -> a, alu_op_b -> b, alu_op -> op);
let reg (reg_left <- reg_left, reg_right <- reg_right) <= regfile@{clk} (reg_in, reg_wr);
let mem (mem_out) <= memory<data<u32>>@{clk}(mem_in -> mem_in, mem_wr -> wr_en);
let pc (pc_addr) <= program_counter@{clk}(pc_target -> target, pc_set -> set, pc_incr -> incr);
let overflow <= reg@{clk}::ctrl<1>;

match state@{clk}:
    states::fetch:
        '1 -> pc_incr;

        pc@{clk} + 1 -> pc@{clk+1};
    states::exec:
	match
	    add(_, left, right, out, _): {
		ops::ad -> alu_op;
		regleft[left]@{clk} -> alu_op_a;
		regright[right]@{clk} -> alu_op_b;
		alu_result<0:32> -> regin[out]@{clk+1};
		alu_result<32> as ctrl -> overflow@{clk+1};
		pc@{clk} + 1 -> pc@{clk+1};
		states::exec => state@{clk+1};
	    }
	    mult(_, left, right, out, _): {
		ops::mult -> alu_op;
		regleft[left]@{clk} -> alu_op_a;
		regright[right]@{clk} -> alu_op_b;
		alu_result<0:32>@{clk+3} -> regin[out]@{clk+4};
		pc@{clk} + 1 -> pc@{clk+1};
		states::wait => state@{clk+1};
		states::exec => state@{clk+4};
		'0 -> overflow@{clk+1};
	    }
	    bre(_, left, right, target, _): {
		if regleft[left]@{clk} == regright[right]@{clk}:
		    regcenter[target]@{clk} -> pc@{clk+1};
		else:
		    pc@{clk} + 1 -> pc@{clk+1};
		states::exec => state@{clk+1};
		'0 -> overflow@{clk+1};
	    }
	    fetch(_, addr, reg, _): {
		mem_out[reg_left[reg]@{clk}]@{clk+1} -> reg_in[reg]@{clk+2};
		states::wait => state@{clk+1};
		states::exec -> state@{clk+2};
		pc@{clk} + 1 -> pc@{clk+1};
		'0 -> overflow@{clk+1};
	    }
	    default: pc@{clk} + 1 -> pc@{clk+1};
    states::wait: pass
}
